---
- name: Common packaging tasks
  when: _common_packages is defined
  vars:
    __cmdline: /usr/bin/paru --sudoflags "--stdin" --noconfirm
    __assert: &paru-assert
      register: __paru_invocation
      changed_when: __paru_invocation.rc == 0
  block:
    - name: Remove packages
      when: _common_packages.remove is defined
      ansible.builtin.command:
        cmd: "{{ __cmdline }} --remove --recursive {{ _common_packages.remove | join(' ') }}"
        stdin: "{{ users.user.password }}"
      register: __paru_invocation
      failed_when: false
      changed_when: __paru_invocation.rc == 0

    - name: Sync the database, update the system, or do both
      <<: *paru-assert
      when: _common_packages.sync is true or _common_packages.upgrade is true
      ansible.builtin.command:
        cmd: >-
          {{ __cmdline }}
          {{ _common_packages.sync is true | ternary('--refresh', '') }}
          {{ _common_packages.upgrade is true | ternary('--sysupgrade', '') }}
        stdin: "{{ users.user.password }}"

    - name: Install packages
      <<: *paru-assert
      when: _common_packages.install is defined
      ansible.builtin.command:
        cmd: >-
          {{ __cmdline }}
          {{ ['--sync', _common_packages.force is true | ternary(none, '--needed')] | reject('none') | join(' ') }}
          {{ _common_packages.install | join(' ') }}
        stdin: "{{ users.user.password }}"

- name: Common installing tasks (akin install(1))
  when: _common_install is defined
  vars:
    __defaults: >-
      {{
        {
          'become': False,
          'wipe': False,
          'filemode': '0644',
          'dirmode': '0755',
          'base': users.user.config,
        } | ansible.builtin.combine(_common_install.defaults | default({}))
      }}
    __become: "{{ item.value.become | default(__defaults.become) }}"
    __ownership: &install-ownership
      owner: "{{ item.value.become | default(__defaults.become) is true | ternary(0, omit) }}"
      group: "{{ item.value.become | default(__defaults.become) is true | ternary(0, omit) }}"
  block:
    - name: Wipe explicitly marked directories
      when: policy.destructive is true and _common_install.wipes is defined
      ansible.builtin.file:
        path: "{{ item is abs | ternary(item, [__defaults.base, item] | path_join) }}"
        state: absent
      loop: "{{ _common_install.wipes }}"
      become: "{{ __become }}"

    - name: Wipe target directories
      when: policy.destructive is true and _common_install.targets is defined
      ansible.builtin.file:
        path: >-
          {{
            item.key is abs | ternary(
              item.key,
              [item.value.base | default(__defaults.base), item.key] | path_join
            )
          }}
        state: absent
      vars:
        __wipe_targets: >-
          {{
            _common_install.targets | dict2items | selectattr('value.wipe', 'true')
            + (_common_install.targets | dict2items | selectattr('value.wipe', 'undefined') if __defaults.wipe else [])
          }}
      loop: >-
        {{
          dict(__wipe_targets | map(attribute='key') | map('dirname') | zip(__wipe_targets | map(attribute='value')))
            | dict2items | selectattr('key', 'ne', '')
        }}
      become: "{{ __become }}"

    - name: Ensure target directories are created
      when: _common_install.targets is defined
      ansible.builtin.file:
        path: >-
          {{
            item.key is abs | ternary(
              item.key,
              [item.value.base | default(__defaults.base), item.key] | path_join
            )
          }}
        state: directory
        mode: "{{ item.value.dirmode | default(__defaults.dirmode) }}"
        <<: *install-ownership
      vars:
        __targets: "{{ _common_install.targets | dict2items }}"
      loop: >-
        {{
          dict(__targets | map(attribute='key') | map('dirname') | zip(__targets | map(attribute='value')))
            | dict2items | selectattr('key', 'ne', '')
        }}
      become: "{{ __become }}"

    - name: Copy files to the target directory
      when: _common_install.targets is defined
      ansible.builtin.copy:
        src: "{{ item.value.file }}"
        dest: "{{ item.key is abs | ternary(item.key, [__defaults.base, item.key] | path_join) }}"
        mode: "{{ item.value.filemode | default(__defaults.filemode) }}"
        <<: *install-ownership
      loop: "{{ _common_install.targets | dict2items | selectattr('value.file', 'defined') }}"
      become: "{{ __become }}"

    - name: Render templates to the target directory
      when: _common_install.targets is defined
      ansible.builtin.template:
        src: "{{ item.value.template }}"
        dest: "{{ item.key is abs | ternary(item.key, [__defaults.base, item.key] | path_join) }}"
        mode: "{{ item.value.filemode | default(__defaults.filemode) }}"
        lstrip_blocks: true
        trim_blocks: true
        <<: *install-ownership
      loop: "{{ _common_install.targets | dict2items | selectattr('value.template', 'defined') }}"
      become: "{{ __become }}"

    - name: Render files to the target directory
      when: _common_install.targets is defined
      ansible.builtin.copy:
        content: "{{ item.value.content }}"
        dest: "{{ item.key is abs | ternary(item.key, [__defaults.base, item.key] | path_join) }}"
        mode: "{{ item.value.filemode | default(__defaults.filemode) }}"
        <<: *install-ownership
      loop: "{{ _common_install.targets | dict2items | selectattr('value.content', 'defined') }}"
      become: "{{ __become }}"

    - name: Create necessary links
      when: _common_install.targets is defined
      ansible.builtin.file:
        src: "{{ item.value.link }}"
        dest: "{{ item.key is abs | ternary(item.key, [__defaults.base, item.key] | path_join) }}"
        state: link
        follow: false
        force: true
      loop: "{{ _common_install.targets | dict2items | selectattr('value.link', 'defined') }}"
      become: "{{ __become }}"

    - name: Touch necessary files
      when: _common_install.targets is defined
      ansible.builtin.file:
        path: "{{ item.key is abs | ternary(item.key, [__defaults.base, item.key] | path_join) }}"
        state: touch
        mode: "{{ item.value.filemode | default(__defaults.filemode) }}"
        <<: *install-ownership
      loop: "{{ _common_install.targets | dict2items | selectattr('value.touch', 'defined') }}"
      become: "{{ __become }}"

- name: Common systemd service management
  when: _common_services is defined
  ansible.builtin.systemd_service:
    name: "{{ item.key }}"
    scope: "{{ item.value.user is true | ternary('user', omit) }}"
    daemon_reload: "{{ item.value.reload is true | ternary(true, omit) }}"
    masked: "{{ item.value.mask is true | ternary(true, omit) }}"
    enabled: >-
      {{
        (
          item.value.enable is true | ternary(true, None)
          or item.value.disable is true | ternary(false, None)
        ) | ternary(true, false, omit)
      }}
    state: >-
      {{
        (
          item.value.enable is true | ternary(true, None)
          or item.value.start is true | ternary(true, None)
          or item.value.disable is true | ternary(false, None)
          or item.value.mask is true | ternary(false, None)
          or item.value.stop is true | ternary(false, None)
        ) | ternary('restarted', 'stopped', omit)
      }}
  environment:
    SYSTEMD_OFFLINE: "{{ '1' if ansible_connection == 'nspawn' else omit }}"
    SYSTEMD_IN_CHROOT: "{{ '1' if ansible_connection == 'nspawn' else omit }}"
  become: "{{ item.value.user is true | ternary(omit, true) }}"
  loop: "{{ _common_services | dict2items }}"

- name: Get GnuPG key metadata
  when: _common_gpg is defined
  block:
    - name: Read metadata file
      ansible.builtin.slurp:
        src: "{{ users.user.home }}/.gnupg/{{ security.gpg.metadata }}"
      register: __metadata_file

    - name: Process metadata file as JSON
      ansible.builtin.set_fact:
        _common_gpg_invocation: "{{ (__metadata_file.content | b64decode | from_json)[_common_gpg] }}"

#
# TODO:
#  add _common_pull.[].type = archive/command/file
#  add _common_push.[].type = archive/file
#
- name: Common backup pull operation
  when: _common_pull is defined
  vars:
    __become: "{{ _common_pull.become is true | ternary(true, omit) }}"
  block:
    - name: Create archive
      ansible.builtin.shell:
        chdir: >-
          {{
            _common_pull.base is abs | ternary(_common_pull.base, [users.user.config, _common_pull.base] | path_join)
          }}
        cmd: >-
          {%- set _exclude = [] -%}
          {%- for _pattern in _common_pull.exclude | default([]) -%}
            {%- set _ = _exclude.append('--exclude={}'.format(_pattern | squote)) -%}
          {%- endfor -%}
          {#--#}
          tar
          --wildcards
          --anchored
          --no-wildcards-match-slash
          --numeric-owner
          --group=0
          --owner=0
          --create
          --to-stdout
          {{ _common_pull.include | join(' ') }}
          {{ _exclude | join(' ') }}
          | base64 --wrap=0
      register: __tar_invocation
      changed_when: __tar_invocation.rc == 0
      become: "{{ __become }}"

    - name: Stat persist directory
      delegate_to: localhost
      ansible.builtin.stat:
        path: "{{ persist.base }}"
      register: __persist_stat

    - name: Ensure persist subdirectory exists
      delegate_to: localhost
      ansible.builtin.file:
        path: "{{ persist.base }}/{{ _common_pull.name | dirname }}"
        state: directory
        mode: "{{ __persist_stat.stat.mode }}"
        owner: "{{ __persist_stat.stat.uid }}"
        group: "{{ __persist_stat.stat.gid }}"

    - name: Save archive to the persist
      ansible.builtin.file:
        dest: "{{ persist.base }}/{{ _common_pull.name }}{{ persist.format }}"
        content: "{{ __tar_invocation.stdout }}"
        mode: "0644"
        owner: "{{ __persist_stat.stat.uid }}"
        group: "{{ __persist_stat.stat.gid }}"

- name: Common backup push operation
  when: _common_push is defined
  vars:
    __base: >-
      {{
        _common_push.base is abs | ternary(_common_push.base, [users.user.config, _common_push.base] | path_join)
      }}
    __become: "{{ _common_push.become is true | ternary(true, omit) }}"
  block:
    - name: Wipe target directory
      when: policy.destructive is true and _common_push.wipe is defined 
      ansible.builtin.file:
        path: "{{ __base }}"
        state: absent
      become: "{{ __become }}"

    - name: Ensure target directory exists
      ansible.builtin.file:
        path: "{{ __base }}"
        state: directory
        mode: "{{ _common_push.mode | default('0755') }}"
        owner: "{{ _common_push.become | default(false) is true | ternary(0, omit) }}"
        group: "{{ _common_push.become | default(false) is true | ternary(0, omit) }}"
      become: "{{ __become }}"

    - name: Unpack archive
      ansible.builtin.unarchive:
        src: "{{ persist.base }}/{{ _common_push.name }}{{ persist.format }}"
        dest: "{{ __base }}"
        extra_opts:
          - --no-same-owner
          - --preserve-permissions
      become: "{{ __become }}"

- name: Common user groups management
  when: _common_groups is defined
  ansible.builtin.user:
    name: "{{ users.user.name }}"
    groups: "{{ _common_groups }}"
    append: true

- name: Common global environmental variables management
  when: _common_environment is defined
  ansible.builtin.lineinfile:
    dest: /etc/environment
    regexp: "^{{ item.key }}"
    line: "{{ item.key }}={{ item.value }}"
  become: true
  loop: "{{ _common_environment }}"
