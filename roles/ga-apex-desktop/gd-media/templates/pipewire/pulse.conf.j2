{%- set _indent = {"space": 4} -%}


#
# PipeWire PulseAudio configuration.
#
context.properties = {
    {{ _gd_context | relative_indent(times=1, **_indent) }}
}

context.spa-libs = {
    audio.convert.* = audioconvert/libspa-audioconvert
    support.* = support/libspa-support
}

context.modules = [
    {{ _gd_realtime | relative_indent(times=1, **_indent) }}

    { name = libpipewire-module-protocol-native }
    { name = libpipewire-module-client-node }
    { name = libpipewire-module-adapter }
    { name = libpipewire-module-metadata }

    { name = libpipewire-module-protocol-pulse }
]

pulse.cmd = [
    { cmd = "load-module" args = "module-always-sink" flags = [ ] }
{% if gd_save is true %}
    { cmd = "load-module" args = "module-device-manager" flags = [ ] }
    { cmd = "load-module" args = "module-device-restore" flags = [ ] }
    { cmd = "load-module" args = "module-stream-restore" flags = [ ] }
{% endif %}
]

stream.properties = {
    {{ _gd_stream | relative_indent(times=1, **_indent) }}
}

pulse.properties = {
    server.address = [
        "unix:native"
    ]

    pulse.idle.timeout = 1

    pulse.min.req = {{ gd_quantum_min }}/48000
    pulse.min.frag = {{ gd_quantum_min }}/48000
    pulse.min.quantum = {{ gd_quantum_min }}/48000
    pulse.default.req = {{ gd_quantum_default }}/48000

{% if gd_cards | dict2items | map(attribute='value.format') | unique | length == 1 %}
    pulse.default.format = {{ (gd_cards | dict2items | first).value.format }}
{% endif %}
}

pulse.rules = [
    #
    # Firefox marks the capture streams as 'do not move'.
    #
    {

        matches = [
            { application.process.binary = "firefox" }
        ]
        actions = { quirks = [ remove-capture-dont-move ] }
    }

    #
    # Speech dispatcher asks for too small latency and then underruns.
    #
    {
        matches = [
            { application.name = "~speech-dispatcher.*" }
        ]
        actions = {
            update-props = {
                pulse.min.req = 512/48000
                pulse.min.quantum = 512/48000
            }
        }
    }

    #
    # WirePlumber already handles this, but it is preferable to explicitly have it here
    #  for better error handling and compatibility.
    #
    {
        matches = [
            {
            {% for _app in gd_whitelist %}
                application.process.binary = "!{{ _app }}"
            {% endfor %}
            }
        ]
        actions = {
            quirks = [ block-source-volume block-sink-volume ]
        }
    }
]
