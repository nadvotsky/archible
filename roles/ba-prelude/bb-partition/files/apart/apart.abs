#
# This is a source code for the apart utility. Licensed under the MIT License.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

#
# Known partition types in the form of: [pseudonym1, pseudonym2, ..., code].
#
PART_TYPE_EFI = ["esp", "efi", "ef00"]
PART_TYPE_LINUX = ["linux", "8300"]
PART_TYPE_SWAP = ["swap", "8200"]
PART_TYPE_ROOT = ["root", "8304"]
PART_TYPE_HOME = ["home", "8302"]
PART_TYPE_NT = ["nt", "win", "0700"]


#
# Allowed partition types and filesystems.
#
PART_TYPE_ALLOW = [
  PART_TYPE_EFI, PART_TYPE_LINUX, PART_TYPE_SWAP, 
  PART_TYPE_ROOT, PART_TYPE_HOME, PART_TYPE_NT
]
PART_FS_ALLOW = [
  "fat32", "ext4", "f2fs", "xfs", "swap", "btrfs", "ntfs", "exfat"
]


#
# A hash of mappings from filesystems to command-line functions for
# the mkfs.* family.
#
# The function receives three arguments:
#  the block device path
#  a name of the partition (which may be an empty string)
#  options fetched from the APART_MKFS_* environmental variable or null
#
MKFS_OPTS = {
  "fat32": f(block, name, options) {
    "mkfs.vfat -F 32 -n $name $block"
  },
  "ext4": f(block, name, options) {
    def_options = [
      "fast_commit",
      "64bit",
      "dir_index",
      "ext_attr",
      "extent",
      "filetype",
      "flex_bg",
      "has_journal",
      "inline_data",
      "large_dir",
      "large_file",
      "sparse_super",
      "metadata_csum"
    ].join(",")
    "mkfs.ext4 -L %s -t ext4 -O %s %s".fmt(name, options || def_options, block)
  },
  "f2fs": f(block, name, options) {
    def_options = [
      "extra_attr",
      "flexible_inline_xattr",
      "inode_checksum"
    ].join(",")
    "mkfs.f2fs -f -i -l %s -O %s %s".fmt(name, options || def_options, block)
  },
  "btrfs": f(block, name, options) {
    def_options = [
      "extref",
      "skinny-metadata",
      "no-holes"
    ].join(",")
    "mkfs.btrfs -f -L %s -O %s %s".fmt(name, options || def_options, block)
  },
  "xfs": f(block, name, options) {
    "mkfs.xfs -L $name -f $block"
  },
  "swap": f(block, name, options) {
    "mkswap -L $name $block"
  },
  "exfat": f(block, name, options) {
    "mkfs.exfat -L $name $block"
  },
  "ntfs": f(block, name, options) {
    "mkfs.ntfs --quick --label %s %s %s".fmt(name, options || "", block)
  }
}


#
# A mapping of partition types to default partition options.
# It is safe to use only the partition number since it is always
# transformed into this form before enhancement begins.
#
PART_ENCHANCE_MAP = {
  PART_TYPE_EFI[-1]: {
    "fs": "fat32",
    "mount": "/boot"
  },
  PART_TYPE_LINUX[-1]: {
    "fs": "ext4"
  },
  PART_TYPE_ROOT[-1]: {
    "fs": "ext4",
    "mount": "/"
  },
  PART_TYPE_SWAP[-1]: {
    "fs": "swap"
  },
  PART_TYPE_HOME[-1]: {
    "fs": "ext4",
    "mount": "/home"
  },
  PART_TYPE_NT[-1]: {
    "fs": "ntfs"
  }
}


#
# Help message sections.
#
CLI_HELP = [
  ["NAME", [
    "apart - automatic disk partitioning, formatting, and mounting utility"
  ]],
  ["SYNOPSIS", [
    "apart [options] <partition1> [<partition2> ...]"
  ]],
  ["DESCRIPTION", [
    "apart is a utility written in ABS that automates disk partitioning,",
    "formatting, and mounting. It accepts a list of partitions expressed in",
    "key=val format and supports percentage-based sizing. The utility utilizes",
    "sgdisk and mkfs.* family under the hood.",
    "",
    "Partitions can be configured with various options, including filesystem",
    "type, partition type, and mount point. By default, apart tries to",
    "automatically guess filesystem and mount points, but this can be disabled",
    "with the -e/--explicit option."
  ]],
  ["EXAMPLES", [
    "apart -d /dev/sda -m /mnt name=EFI,size=1G,type=efi name=ROOT,type=root"
  ]]
]


f log_esc(color, tag, msg) {
  code = {
    "RED": 31,
    "YELLOW": 33,
    "BLUE": 34,
    "CYAN": 36,
  }[color]

  if env("NO_COLOR") == "1" {
    return "%s %s".fmt(tag, msg)
  }

  return "[1;%sm%s[0m %s".fmt(code, tag, msg)
}


log_warn_ignore_list = {}
f log_warn(id, msg) {
  ignore = log_warn_ignore_list[id]
  if ignore {
    return
  }

  log_warn_ignore_list[id] = true
  echo(log_esc("YELLOW", "warn($id):", msg))
  echo(log_esc("YELLOW", "warn(log):", "Message ^^^^ is reported only once"))
}


f log_fatal(id, msg) {
  exit(1, log_esc("RED", "fatal($id):", msg))
}


f os_exec_line(cmd, dry_run=false) {
  if dry_run {
    echo(log_esc("BLUE", "dry-run(exec):", "$cmd"))
    return ""
  }

  echo(log_esc("CYAN", "os(exec):", "$cmd"))

  result = `$cmd`
  if !result.ok {
  echo(result)
    log_fatal("os_exec_line", "Cannot execute external process '$cmd'")
  }

  return result
}


f os_exec(cmd, args, dry_run=false) {
  return os_exec_line("%s %s".fmt(cmd, args.join(" ")), dry_run)
}


f blockdev_get_disk_size(disk) {
  disk_size = os_exec("blockdev", ["--getsz", disk])
  if !disk_size.is_number() {
    log_fatal(
      "blockdev_get_disk_size",
      "Cannot convert blockdev response ($disk_size) to number"
    )
  }

  return disk_size.number()
}


f cli_process_non_argument(subtype, name, c) {
  vals = [c?.short, c?.long].filter(f(x) { type(flag(x)) != "NULL" }).map(f(n) {
    v = flag(n)
    if subtype == "FLG" && type(v) != "BOOLEAN" {
      log_fatal(
        "cli_process_non_argument",
        "'$n' is a flag, unexpected value '$v'"
      )
    } else if subtype == "OPT" && type(v) == "BOOLEAN" {
      log_fatal(
        "cli_process_non_argument",
        "'$n' is not a flag, value expected"
      )
    }
    return v
  })
  if subtype == "OPT" && vals.len() == 2 {
    log_fatal(
      "cli_process_non_argument",
      "Ambiguous usage of both '%s' and '%s' options".fmt(c.short, c.long)
    )
  }

  if type(vals[0]) != "NULL" {
    return vals[0]
  }

  if type(c?.default) != "NULL" {
    return c.default
  }

  log_fatal("cli_process_non_argument", "'$name' must be specified")
}


f cli_process_non_arguments(subtype, conf) {
  ret = {}

  for c in conf {
    name = (c?.long || c?.short).snake()
    ret[name] = cli_process_non_argument(subtype, name, c)
    if (name == "help" || name == "h") && ret[name] {
      return ret
    }
  }

  return ret
}


f cli_process_options(conf) {
  return cli_process_non_arguments("OPT", conf)
}


f cli_process_flags(conf) {
  return cli_process_non_arguments("FLG", conf)
}


f cli_get_arguments(list) {
  result = []
  ignore = ""

  for a in list {		
    if a.prefix("-") {
      ignore = flag(a.split("=")[0].split("-")[-1])
      continue
    }

    if a == ignore {
      continue
    }

    result.push(a)
  }

  if result.len() == 0 {
    log_fatal("cli_get_arguments", "Empty array of arguments")
  }

  return result
}


f cli_process_argument(conf, argument) {
  ret = {}

  for kvs in argument.split(",") {
    k, v = kvs.split("=")
    if [k, v].some(f(x) { type(x) == "NULL" }) {
      log_fatal(
        "cli_parse_argument",
        "'$kvs' cannot be parsed as key=value expression"
      )
    }

    c = conf.find(f(x) { x.name == k })
    if type(c) == "NULL" {
      log_fatal("cli_parse_arguments", "Unexpected argument key '$k' in '$kvs'")
    }

    if type(c?.choice) != "NULL" && v !in c.choice {
      log_fatal(
        "cli_parse_arguments",
        "Unexpected key value '$k' = '$v' (must be one of %s)".fmt(c.choice)
      )
    }

    if type(c?.validate) != "NULL" {
      msg = c.validate(v)
      if type(msg) == "STRING" {
        log_fatal(
          "cli_parse_arguments",
          "Validation failed for '$k' = '$v' ($msg)"
        )
      }
    }

    if k in ret {
      log_fatal("cli_parse_arguments", "Key already exists '$k' = '$v'")
    }

    ret[k] = v.replace("%", "%%")
  }

  return ret
}


f cli_process_arguments(conf, args_list) {
  return args_list.map(f(x) { cli_process_argument(conf, x) })
}


f cli_print_help(options_conf, flags_conf, arguments_conf) {
  echo()
  for tuple in CLI_HELP {
    name, lns = tuple
    echo(name)
    for line in lns {
      echo("\t" + line)
    }
    echo()
  }

  format_helper = f(line, def) {
    line = "\t" + line
    non_empty = type(def) != "NULL" && def != false && def != ""

    if non_empty {
      line += " = "
    }

    if type(def) == "ARRAY" {
      line += def.join("|")
    } else if non_empty {
      line += def.str()
    }

    echo(line)
  }

  desc_helper = f(line) {
    if type(line) == "NULL" {
      return
    }

    if type(line) == "STRING" {
      line = [line]
    }

    for l in line {
      echo("\t\t%s".fmt(l))
    }
  }

  echo("OPTIONS")
  for o in [options_conf, flags_conf].flatten() {
    line = [o?.short, o?.long]
      .filter(f(x) { type(x) != "NULL" })
      .map(f(x) { "-$x" })
      .join("|")
    format_helper(line, o?.default)
    desc_helper(o.desc)
    echo()
  }

  echo("PARTITION EXPRESSION")
  for a in arguments_conf {
    format_helper(a.name, a?.choice)
    desc_helper(a.desc)
    echo()
  }
}


f cli_get_options_conf() {
  return [
    {
      "short": "d",
      "long": "disk",
      "desc": "Specify the target disk to apply changes to."
    },
    {
      "short": "m",
      "long": "mount",
      "default": "",
      "desc": "Specify the mount point that is prepended to partition mount paths."
    }
  ]
}


f cli_get_flags_conf() {
  return [
    {
      "short": "h",
      "long": "help",
      "default": false,
      "desc": "Display this help message and exit."
    },
    {
      "short": "n",
      "long": "dry-run",
      "default": false,
      "desc": "Perform a dry run without actually partitioning or mounting."
    },
    {
      "short": "e",
      "long": "explicit",
      "default": false,
      "desc": "Disable automatic guessing of filesystems and mount points."
    },
    {
      "short": "s",
      "long": "no-summary",
      "default": false,
      "desc": "Do not print detailed information about the partitions."
    }
  ]
}


f cli_get_arguments_conf() {
  return [
    {
      "name": "name",
      "desc": "Specify the name of the partition and the filesystem if formatted."
    },
    {
      "name": "size",
      "desc": [
        "Specify the size of the partition.",
        "It can be in units (e.g., K, M, G) or as a percentage (%%)."
      ],
      "validate": f(x) {
        (x.is_number() || x[:-1].is_number()) ||
          "must be a number, with a optional unit measuremnt suffix"
      }
    },
    {
      "name": "fs",
      "choice": PART_FS_ALLOW,
      "desc": [
        "Specify the filesystem to format this partition.",
        "Use APART_MKFS_{FS} environmental variable to override default options."
      ]
    },
    {
      "name": "type",
      "choice": flatten(PART_TYPE_ALLOW),
      "desc": "Specify the partition type.",
    },
    {
      "name": "mount",
      "desc": "Specify the mount path of this partition, " +
        "appended to the -m/-mount option.",
    }
  ]
}


f cli_parse(args_list) {
  options_conf = cli_get_options_conf()
  flags_conf = cli_get_flags_conf()
  arguments_conf = cli_get_arguments_conf()

  flags = cli_process_flags(flags_conf)
  if flags?.help {
    cli_print_help(options_conf, flags_conf, arguments_conf)
    exit(0)
  }

  options = cli_process_options(options_conf)
  arguments = cli_process_arguments(
    arguments_conf, cli_get_arguments(args_list)
  )

  return [flags, options, arguments]
}


f part_process_partition_type(t, part, explicit) {
  for part_types in PART_TYPE_ALLOW {
    if t in part_types {
      part.ptype_hint = t
      t = part_types[-1]
      break
    }
  }
  part.ptype = t

  if explicit {
    return part
  }

  for code, inject in PART_ENCHANCE_MAP {
    if code != part.ptype {
      continue
    }

    for k in inject.keys().diff(part.keys()) {
      if k in part {
        continue
      }

      log_warn(
        "part_process_partition_type",
        "Enchacement applied: '%s' = '%s'".fmt(k, inject[k])
      )
      part[k] = inject[k]
    }
  }

  return part
}


f part_process_argument(argument, disk_size, explicit, mount) {
  part = {}

  if type(argument?.name) != "NULL" {
    part.name = argument.name
  }

  if type(argument?.size) == "NULL" {
    part.size_hint = "not-specified"
    part.size = "0"
  } else if argument.size.is_number() {
    part.size_hint = "raw-offset"
    part.size = "+%s".fmt(argument.size.number())
  } else if argument.size.suffix("%%") {
    part.size_hint = "percentage"
    part.size_hint_ext = argument.size[:-2].number()
    part.size = "+%s".fmt((disk_size / 100 * part.size_hint_ext).floor())
  } else {
    part.size_hint = "unit"
    part.size = "+%s".fmt(argument.size)
  }

  if type(argument?.fs) != "NULL" {
    part.fs = argument.fs
  }

  if "type" in argument && type(argument["type"]) != "NULL" {
    part = part_process_partition_type(argument["type"], part, explicit)
  }

  new_mount = [argument?.mount, part?.mount].find(f(m) { type(m) != "NULL" })
  if type(new_mount) != "NULL" {
    part.mount_hint = new_mount
    if mount == "" {
      part.mount = null
    } else {
      part.mount = mount + new_mount
    }
  }

  return part
}


f part_process(arguments, options, flags) {
  if arguments.some(f(a) {
    if type(a?.size) == "NULL" {
      return false
    }

    return a.size.suffix("%%")
  }) {
    disk_size = blockdev_get_disk_size(options.disk)
  } else {
    disk_size = null
  }

  return arguments.map(f(a) {
    part_process_argument(a, disk_size, flags.explicit, options.mount)
  })
}


f sgdisk_process(parts, disk, dry_run) {
  cmdline = [disk, "--clear"]
  for i, p in parts {
    cmdline.push("--new=%s:0:%s".fmt(i + 1, p.size))
    if type(p?.ptype) != "NULL" {
      cmdline.push("--typecode=%s:%s".fmt(i + 1, p.ptype))
    }
    if type(p?.name) != "NULL" {
      cmdline.push("--change-name=%s:\"%s\"".fmt(i + 1, p.name))
    }
   }

  os_exec("sgdisk", cmdline, dry_run)
}


f lsblk_inject_blocks(parts, disk, dry_run) {
  lsblk = os_exec(
    "lsblk",
    [disk, "--raw", "--output", "NAME", "--noheadings"],
    dry_run
  )
  if dry_run {
    blocks = (1..parts.len()).map(f(i) { "null/$i" })
  } else {
    blocks = lsblk.split("\n").map(trim).filter(f(l) { l.len() != 0 })[1:]
  }
  if blocks.len() == 0 || blocks.len() != parts.len() {
    log_fatal("lsblk_inject_blocks", "Cannot retrieve block devices for $disk")
  }

  for i in 1..blocks.len() {
    parts[i - 1].block = "/dev/" + blocks[i - 1]
  }

  return parts
}


f mkfs_process(parts, dry_run) {
  for part in parts {
    if type(part?.fs) == "NULL" {
      continue
    }

    if part.fs !in MKFS_OPTS {
      log_fatal("mkfs_process", "Unknown fs '%s'".fmt(part.fs))
    }

    options = env("APART_MKFS_%s".fmt(part.fs.upper())).trim()
    if options.len() == 0 {
      options = null
    }

    echo(os_exec_line(
      MKFS_OPTS[part.fs](part.block, "\"%s\"".fmt(part?.name || ""), options),
      dry_run
    ))
  }
}


f mount_process(parts, dry_run) {
  mounts = parts
    .map(f(p) { p?.mount_hint })
    .filter(f(m) { type(m) != "NULL" })
    .sort()

  for m in mounts {
    part = parts.find(f(p) { p?.mount_hint == m })
    if type(part) == "NULL" {
      continue
    }

    if type(part.mount) == "NULL" {
      log_warn(
        "mount_process",
        "Base mount mount is undefined, cannot mount '%s'".fmt(part.mount_hint)
      )
      continue
    }

    os_exec("mkdir", ["-p", part.mount], dry_run)
    os_exec("mount", [part.block, part.mount], dry_run)
  }
}


f verbose_summary(parts, no_summary) {
  if no_summary {
    return
  }

  echo()
  for i, part in parts {
    echo(" Partition [%s]:".fmt(i + 1))
    echo("  Name       : %s".fmt(part?.name))
    echo("  Type       : %s".fmt(part?.ptype_hint))
    echo("  Raw Type   : %s".fmt(part?.ptype))
    echo("  Size       : %s %s".fmt(part?.size_hint, part?.size_hint_ext || ""))
    echo("  Raw Size   : %s".fmt(part?.size))
    echo("  File System: %s".fmt(part?.fs))
    echo("  Block      : %s".fmt(part?.block))
    echo("  Mount      : %s".fmt(part?.mount_hint))
    echo("  Raw Mount  : %s".fmt(part?.mount))
    echo()
  }
}


f main() {
  flags, options, arguments = cli_parse(args()[2:])
  parts = part_process(arguments, options, flags)

  sgdisk_process(parts, options.disk, flags.dry_run)

  parts = lsblk_inject_blocks(parts, options.disk, flags.dry_run)
  verbose_summary(parts, flags.no_summary)

  mkfs_process(parts, flags.dry_run)
  mount_process(parts, flags.dry_run)
}

main()
