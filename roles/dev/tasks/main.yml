---
#
# Version management is a massive and complex topic.
# Most notably, there are:
#
# mise-en-place:
#  uses own JVM index (https://github.com/jdx/rtx-java-metadata),
#   but unsupported JVMs can still be linked manually (https://mise.jdx.dev/lang/java.html#idiomatic-version-files).
#  no dotnet support
# proto
#  no JVM support
#  tricky local/global switch
#  ~2 times slower shell-hook than mice
#  non-XDG compliant ($HOME/.proto)
#  relatively poor tools support (dotnet does not set DOTNET_ROOT, same for rust, maybe others)
# vfox
#  dotnet only parses latest releases, LTS versions are not available
#  python is not prebuilt, downloads pyenv instead
# VMR
#  basically conda
#  no graalvm
#  no shell hook
#  tricky cli, meant to be used interactively
# aqua
#  various small github packages, but no big frameworks like Java, dotnet, etc.
#  native, but still shim, no shell hook
#
# Conda-based (Mamba/Pixi)
#  complicated distribution with its own runtime (such as libc)
#  dotnet is old
#  only OpenJDK
#  no libstdc++ and other advanced features
# Mamba (MicroMamba)
#  no local packages list, global environments instead
# Pixi
#  stores packages in-place
#
# Nix
#  slow to build (3.5G+), as well as messes the PATH
#  overall slower
# devbox
#  5 times slower (100ms vs 20ms) than mise
#  way too many environmental variables
# flox
#  complicated installation
#
# JetBrains Dev Containers
#  downloads additional images 1.5G + 500M
#  uses a lot of RAM, because of IDE + gateway + container
#  problems with agent
# VSCode Containers
#  relatively good, but VSCode is not the best option for specific languages
# devpod
#  launcher for other IDEs
#  ssh invocations, background jobs
# Docker
#  slow at jetbrains ide
# Distrobox, Toolbox
#  bundles x11, hardware accelaration problems, etc
# importctl & systemd-nspawn
#  requires provisioning
#  still has some workarounds, e.g. /usr/local/ and .venv
#  ssh from IDE
#
#
# General rule: DO NOT modify environment variables globally, even if it is something safe.
#
# Same goes for anything else:
#  IDEs do not assign nor use JAVA_HOME
#  mise do not install with --global flag
#
# Instead use a different approach:
#  Make non-default user configuration if possible:
#   additional rust profile, but not default one
#   additional cmake toolchain
#  Use mise environmental variables
#
# This would make make project-specific cofiguration, and thus:
#  does not affect system level: paru, makepkg.
#  does not hardcode it in /etc/environment, .profile or shell, easy to opt out
#  can be comfortably stored in ~/env/examples
#

- name: Prepare JetBrains IDEs
  tags:
    - dev-jetbrains-base
  ansible.builtin.import_tasks:
    file: jetbrains/base.yml

- name: Configure C++ developer suite
  tags:
    - dev-cplusplus
  ansible.builtin.import_tasks:
    file: langs/cplusplus.yml

- name: Configure Rust developer suite
  tags:
    - dev-rust
  ansible.builtin.import_tasks:
    file: langs/rust.yml

- name: Configure Go developer suite
  tags:
    - dev-go
  ansible.builtin.import_tasks:
    file: langs/go.yml

- name: Configure Python developer suite
  tags:
    - dev-python
  ansible.builtin.import_tasks:
    file: langs/python.yml

- name: Configure JavaScript developer suite
  tags:
    - dev-js
  ansible.builtin.import_tasks:
    file: langs/javascript.yml

- name: Configure Java developer suite
  tags:
    - dev-java
  ansible.builtin.import_tasks:
    file: langs/java.yml

- name: Configure C# developer suite
  tags:
    - dev-dotnet
  ansible.builtin.import_tasks:
    file: langs/dotnet.yml

- name: Configure containers
  tags:
    - dev-containers
  ansible.builtin.import_tasks:
    file: misc/containers.yml

- name: Configure editors
  tags:
    - dev-editors
  ansible.builtin.import_tasks:
    file: misc/editors.yml
